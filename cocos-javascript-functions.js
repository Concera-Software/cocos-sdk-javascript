/***
 *     ___      ___     ___ 
 *    / __|___ / __|___/ __|
 *   | (__/ _ \ (__/ _ \__ \
 *    \___\___/\___\___/___/, grown by (concera
 * 
 * -------------------------------------------------------------------------------------------------
 * @author(s)		Stefan van Buren
 * @copyright 		Concera Software - https://concera.software
 * @dateCreated		2017-??-??
 * @lastChange		2020-06-15
 * @version		1.20.166
 * -------------------------------------------------------------------------------------------------
 *
 * -- CHANGELOG:
 * 
 * All notable changes to this project will be documented in this file. The format will be based on
 * the example below. The first line will indicate when, in what version and who made the change(s),
 * followed by the change(s). (1 tab indented). When multiple changes for the same day / version /
 * developer, use multiple lines to list them all. Use one of these types: 'Added', 'Changed',
 * 'Deprecated', 'Removed', 'Fixed' or 'Security', to indicate the type of change that was made.
 * 
 *  date		version		who
 *  	[Type] what...
 *  	[Type] what else...
 *
 *  2020-06-15		1.20.166	SvB
 *  	[Added] Added function removeFromArray.
 *
 *  2020-05-15		1.20.135	SvB
 *  	[Added] Added a variaty of function for converting colors from rgb/rgba to hex/hsl and
 *	vice versa. Also, added functions in order to get a lighter/darker tone for a color,
 * 	detecting if the color is light/dark and getting a contrasting color, based on the given
 *	hex/rgb colorcode.
 *
 *  2020-04-18		1.20.108	SvB
 *  	[Added] Added functions jsonSortByKey and jsonSortByValue.
 *
 *  2020-03-24		1.20.083	SvB
 *  	[Added] Function isValidStringWithChecksum, in order to check if the given string seems
 *	to be a valid checksum (barcode), generated by the CoCoS API. 
 *
 *  2020-02-17		1.20.047	SvB
 *  	[Added] Method isCoCoSApiID added.
 *	[Added] Methods splitName and firstNameToInitials added.
 *	[Fixed] Solved a bug in the copyToClipboard-function.
 *
 *  2019-12-13		1.19.346	SvB
 *  	[Added] Function objectSortByValue() added.
 *	[Fixed] Fixed a small bug in the conversion to human readable times, now also able to
 *	show milliseconds correcly.
 *	[Changed] Functions for convertings dates can now be added with a language-parameter in
 *	order to force which language should be used for translating months and weekdays. 
 *	[Changed] Changed functions isTrue and isFalse, now also accepting values 'yes' and 'no'.
 *
 *  2019-09-19		1.19.261	SvB
 *  	[Added] Function clone() added.
 *
 *  2019-08-28		1.19.239	SvB
 *	[Added] Function isHex-added in order to detect a HEX-string.
 *	[Changed] When formating as HTML, the formatHexadecimalNumber-function will add fake spaces
 *	between each 2 characters in order to create a beter readable HEX-string.
 *
 *  2019-08-12		1.19.223	SvB
 *  	[Fixed] Fixed a bug in the convertDuration-function, returning incorrect duration when 0 seconds
 *	or 0 minutes in the duration.
 *
 *  2019-08-07		1.19.218	SvB
 *  	[Added] The formatDate-function now also supports U for showing microtime.
 *	[Fixed] When no seconds are given to the utcToLocal-function, these will be automatically added
 *	by addding :00 to the given time.
 *	
 *  2019-06-17		1.19.167	SvB
 *  	Added the getDaylightSavingTimeOffset()-function for getting the offset for daylight saving
 *  	time, based on the current date.
 *      
 *  2019-04-21		1.19.110	SvB
 *  	Added parameter allowWhitespace to the isEmpty-function in order to indicate if a whitespace
 * 	must be indicated as empty or not.
 *	Added functions copyToClipboard and copyWindowLocationToClipboard
 *	Changed function utcToLocalTime, utcToLocalTimeSeconds and utcToLocalTimeMillliseconds, which
 *	will use 2000-01-01 (no daylight saving time) when no date is given.
 *      
 *  2019-01-22		1.19.021	SvB
 *  	Added the String.prototype.repeat-method for repeating a string, to be compatible with older
 *  	browsers.
 *
 *  2018-12-07		1.18.340	SvB
 *	Changed the extract function to allow arguments instead of an array when calling it. So
 *	instead of extract(response, ['data', 0, 'data', 'id']); it can now also be called using
 *      arguments, like extract(response, 'data', 0, 'data', 'id'); 
 * 	
 *  2018-11-19		1.18.322	SvB
 *  	Changed the utcToLocal-function to actively split and send milliseconds from a timestamp
 *  	onto the formatDate-function in order to generate a correct date-time, formatted with the
 *  	milliseconds with 4 numbers. By default, the JavaScript Date()-object only provides up to
 *  	3 numbers for milliseconds. In combination with an faulty pad-function, this caused the
 *  	timestamps being wrongly displayed.
 *
 *  2018-11-05		1.18.308	SvB
 *  	Merged files with functions-file from CoCoS Management onto this file, so all applications
 * 	now use the same extra JavaScript Functions.
 *
 *  2018-08-13		1.18.204	SvB
 *  	Added functions for getting and converting dates and times from and to UTC.
 *
 *  2018-07-24		1.18.204	SvB
 *  	Added function isArray()
 *
 * -------------------------------------------------------------------------------------------------
 *
 * # FILEDESCRIPTION:
 * 
 * During development the development of the CoCoS Management and all kinds of web-applications,
 * we've created various JavaScript-functions which were considered useful. To ensure that these
 * functions are available everywhere, we created this file. This is not a library, just a gathering
 * of of all kinds of custom JavaScript-functions which are used by the CoCoS applications and can
 * be handy to use.
 * 
 */

// Counter for unique identifier generation
//
var __COCOS_UNIQUE_ID_COUNTER__=0;

/* getIdentifier()
 *
 * Function for getting a unique identifier to use in stack, panel and view
 * names and handlerQueue.
 *
 */
function getUniqueId(withRandom)
{
	// Increase counter
	__COCOS_UNIQUE_ID_COUNTER__++;

	// To make sure it's absolutely impossible to return the same identifier
	// twice, we add a random number between 1111 and 9999 to the idCounter.
	//
	// The output will be something like: 21_7902.
	//
	return __COCOS_UNIQUE_ID_COUNTER__+(!isFalse(withRandom)?'_'+Math.round((Math.random()*8888)+1111):'');
};

/**
 * Gets the unique identifier by time.
 *
 * @param      {<type>}  withRandom  The with random
 * @return     {<type>}  The unique identifier by time.
 */
function getUniqueIdByTime(withRandom)
{
   return microtime(true).toString().replace(/[.|,]/ , '_')+(!isFalse(withRandom)?'_'+Math.round((Math.random()*8888)+1111):'');
};

/**
 * { function_description }
 *
 * @param      {<type>}  get_as_float  The get as float
 * @return     {<type>}  { description_of_the_return_value }
 */
function microtime(get_as_float)
{
	var unixtime_ms = (new Date).getTime();
	var sec = Math.floor(unixtime_ms/1000);
	return get_as_float ? (unixtime_ms/1000) : (unixtime_ms - (sec * 1000))/1000 + ' ' + sec;
};

/**
 * Gets the browser language.
 *
 * @return     {<type>}  The browser language.
 */
function getBrowserLanguage()
{
	return (navigator.language || navigator.userLanguage).toLowerCase();
};

/**
*
*  Base64 encode / decode
*  http://www.webtoolkit.info/
*
**/
var Base64 =
{
	// private property
	_keyStr : 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',

	// public method for encoding
	encode : function (input)
	{
		var output = '';
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		input = Base64._utf8_encode(input);

		while (i < input.length)
		{
			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2))
			{
				enc3 = enc4 = 64;
			}
			else if (isNaN(chr3))
			{
				enc4 = 64;
			}

			output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
		}

		return output;
	},

	// public method for decoding
	decode : function (input)
	{
		var output = '';
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

		while (i < input.length)
		{
			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64)
			{
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64)
			{
				output = output + String.fromCharCode(chr3);
			}

		}

        	output = Base64._utf8_decode(output);

        	return output;

	},

	// private method for UTF-8 encoding
	_utf8_encode : function (string)
	{
		string = string.replace(/\r\n/g,"\n");
		var utftext = '';

        	for (var n = 0; n < string.length; n++)
		{
			var c = string.charCodeAt(n);

			if (c < 128)
			{
				utftext += String.fromCharCode(c);
			}
			else if((c > 127) && (c < 2048))
			{
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			}
			else
			{
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}
		}

		return utftext;
	},

	// private method for UTF-8 decoding
	_utf8_decode : function (utftext)
	{
		var string = '';
        	var i = 0;
        	var c = c1 = c2 = 0;

        	while ( i < utftext.length )
		{
			c = utftext.charCodeAt(i);

			if (c < 128)
			{
				string += String.fromCharCode(c);
				i++;
			}
			else if((c > 191) && (c < 224))
			{
				c2 = utftext.charCodeAt(i+1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			}
			else
			{
				c2 = utftext.charCodeAt(i+1);
				c3 = utftext.charCodeAt(i+2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}
		}

		return string;
	}
}

if ((typeof(btoa) === 'undefined') && (typeof(atob) === 'undefined'))
{
        _keyStr = Base64._keyStr;
        btoa = Base64.encode;
        atob = Base64.decode;
}

/**
 * { function_description }
 *
 * @param      {<type>}  input   The input
 * @return     {<type>}  { description_of_the_return_value }
 */
function base64_encode(input)
{
	return Base64.encode(input);
}

/**
 * { function_description }
 *
 * @param      {<type>}  input   The input
 * @return     {<type>}  { description_of_the_return_value }
 */
function base64_decode(input)
{
	return Base64.decode(input);
}

/**
 * Prepends a child.
 *
 * @param      {<type>}  element        The element
 * @param      {<type>}  parentElement  The parent element
 */
function prependChild(element,parentElement)
{
	var firstchild = parentElement.childNodes[0];
	parentElement.insertBefore(element,firstchild);
}

function prependToHead(element)
{
	var head = document.getElementsByTagName('head')[0];
	prependChild(element, head);
}

function prependToBody(element)
{
	var body = document.getElementsByTagName('body')[0];
	prependChild(element, body);
}

function appendToHead(element)
{
	var head = document.getElementsByTagName('head')[0];
	head.appendChild(element);
}

function appendToBody(element)
{
	var body = document.getElementsByTagName('body')[0];
	body.appendChild(element);
}

/**
 * Function to check if a given value is set, not undefined, not null.
 *
 * @param  {mixed} val The value to check
 * @return {bool}      The outcome of the check, true for set, false if not.
 */
function isset(val)
{
	try
	{
		return ((typeof(val) !== 'undefined') && (typeof(val) != null) && (val !== null));
	}
	catch (err)
	{
		return false;
	}
};

/**
 * Function to check if a given value is empty or not...
 *
 * @param  {mixed} val The value to check
 * @return {bool}      The outcome of the check, true for empty, false if not.
 */
function isEmpty(val, allowWhiteSpace)
{
	// Return true when value is not set (null / undefined / etc.);
	if(!isset(val))
	{
		return true;
	}

	// Return true when value is an empty string and whitespace is not allowed
	//
	if(!isTrue(allowWhiteSpace) && isString(val) && (trim(val) === ''))
	{
		return true;
	}
	
	// Return true when value is an empty object
	// if(isObject(val) && (!isset(val.length) || (val.length == 0))) <-- OLD METHOD: Changed on 2017-10-12
	if(isObject(val) && ((isset(val.length) && (val.length === 0) || (Object.keys(val).length) === 0)))
	{
		return true;
	}

	return (!isset(val) || (val === ''));
};

function empty(val)
{
	return isEmpty(val)
};

/**
 * Function to check if a given value is NULL or not...
 *
 * @param  {mixed} val The value to check
 * @return {bool}      The outcome of the check, true for null, false if not.
 */
function isNull(val)
{
	return (
	        !isset(val)
	        && (val === null)
	);
};

/**
 * Function to check if a given value is TRUE of not...
 *
 * @param  {bool} bool The boolean to check
 * @return {bool}      The outcome of the check, true for true, false if not.
 */
function isTrue(bool)
{
	return (
		isset(bool)
		&& (
		    (bool === true)
		    || (bool === 'true')
		    || (bool === 1)
		    || (bool === '1')
		    || (bool === 'yes')
		)
	);
};

/**
 * Function to check if a given value is FALSE or not...
 *
 * @param  {bool} bool The boolean to check
 * @return {bool}      The outcome of the check, true for true, false if not.
 */
function isFalse(bool)
{
	return (
		isset(bool)
		&&
		(
		 	isNull(bool)
		 	|| (bool === false)
		 	|| (bool === 'false')
		 	|| (bool === '')
		 	|| (bool === 0)
		 	|| (bool === '0')
		 	|| (bool === 'no')
		)
	);
};

/**
 * Function to check if a given value is a function or not...
 *
 * @param  {function} func The function to check
 * @return {bool}     The outcome of the check, true for function, false if not.
 */
function isFunction(func)
{
	return (
		isset(func)
		&& (typeof(func) == 'function')
	);
};

/**
 * Function to check if a given value is a string or not...
 *
 * @param  {string}  string The string to check
 * @return {bool}           The outcome of the check, true for object, false if not.
 */
function isString(string)
{
	return (
		isset(string)
		&& (typeof(string) == 'string')
	);
};

/**
 * Function to check if a given value is a object or not...
 *
 * @param  {object}  obj The object to check
 * @return {bool}        The outcome of the check, true for object, false if not.
 */
function isObject(obj)
{
	return (
	        isset(obj)
	        && (typeof(obj) == 'object')
	);
}

/**
 * Function to check if a given value is an array or not...
 *
 * @param  {object}  array The array to check
 * @return {bool}          The outcome of the check, true for array, false if not.
 */
function isArray(array)
{
	return (
	        isset(array)
	        && !isNull(array)
	        && (array.constructor.toString().indexOf('Array') > -1)
	);
}

// http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
function isNumeric(n)
{
  return !isNaN(parseFloat(n)) && isFinite(n);
}

// https://stackoverflow.com/questions/5317320/regex-to-check-string-contains-only-hex-characters
function isHex(hex)
{
	return new RegExp(/^([0-9A-Fa-f]{2})+$/).test(hex);
}

/**
 * Determines if json string.
 *
 * @source     https://stackoverflow.com/questions/3710204/how-to-check-if-a-string-is-a-valid-json-string-in-javascript-without-using-try
 * @param      {string}   jsonString  The json string
 * @return     {boolean}  True if json string, False otherwise.
 */
function isJsonString(jsonString)
{
	if (/^\s*$/.test(jsonString)) return false;
	jsonString = jsonString.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
	jsonString = jsonString.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
	jsonString = jsonString.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
	return (/^[\],:{}\s]*$/).test(jsonString);
}

/**
 * { function_description }
 *
 * @param      {<type>}  array   The array
 * @return     {<type>}  { description_of_the_return_value }
 */
function filterArray(array)
{
	if(isArray(array))
	{
		var filteredArray = array.filter
		(
		 	function(el)
		 	{
		  		return !isEmpty(el);
			}
		);

		return filteredArray;
	}

	return null;
}

/**
 * { function_description }
 *
 * @param      {<type>}  originalArray  The original array
 * @param      {<type>}  key            The key
 * @return     {Array}   { description_of_the_return_value }
 */
function sliceFromArray(originalArray, key)
{
	var x;
	var tmpArray = new Array();
	for(x in originalArray)
	{
		if(x != key)
		{
			tmpArray.push(originalArray[x]);
		}
 	}

 	return tmpArray;
};

/**
 * Removes a from array.
 *
 * @param      {string}  array   The array
 * @param      {<type>}  value   The value
 * @return     {string}  { description_of_the_return_value }
 */
function removeFromArray(array, value)
{
	var index = array.indexOf(value);
	if (index > -1)
	{
		array.splice(index, 1);
	}
	return array;	
}

/**
 * [objectSort description]
 * @param  {[type]} unsortedObject [description]
 * @param  {[type]} reverse        [description]
 * @return {[type]}                [description]
 */
function objectSort(unsortedObject, reverse)
{
	var sortedObject = {};
	Object.keys(unsortedObject).sort().forEach(function(key)
	{
		sortedObject[key] = unsortedObject[key];
	});

	return sortedObject;
};

function objectSortByValue(unsortedObject, keys)
{
	var argumentLength = arguments.length;
	if(argumentLength > 2)
	{
		var _keys = [];
		for(var i in arguments)
		{
			if((i > 0) && (arguments.hasOwnProperty(i)))
			{
				_keys.push(arguments[i]);
			}
		}

		if(_keys.length > 1)
		{
			keys = _keys;
		}
		else
		{
			keys = _keys.shift();
		}
	}

	sortedObject = unsortedObject.sort(function (a, b){
		var valueA = extract(a, keys);
		var valueB = extract(b, keys);
		return valueA.localeCompare(valueB);
	});

	return sortedObject;
}

/**
 * Function to get the lenght of an Javasctipt-object (JSON-object).
 *
 * @method cocosAPI._objectLength
 * @access private
 * @param  {Object}  obj  The object which length needs to be checked.
 * @return {Number}       The length of the object. When nothing is
 *                        found, 0 will be returned.
 */
function objectSize(obj)
{
	var count = 0;
	var i;

	if(isObject(obj))
	{
		for (i in obj)
		{
			if (obj.hasOwnProperty(i))
			{
				count++;
			}
		}
	}

	return count;
};

/**
 * { function_description }
 *
 * @param      {<type>}  jsonObject  The json object
 * @return     {<type>}  { description_of_the_return_value }
 * @source     https://smoothprogramming.com/javascript/sort-json-key-value-javascript/
 */
function jsonSortByKey(jsonObject)
{
	var sortedArray = [];

	// Push each JSON Object entry in array by [key, value]
	for(var i in jsonObject)
	{
		sortedArray.push([i, jsonObject[i]]);
	}

	// Run native sort function and returns sorted array.
	return sortedArray.sort();
}

/**
 * { function_description }
 *
 * @param      {<type>}  jsonObject  The json object
 * @return     {<type>}  { description_of_the_return_value }
 * @source     https://smoothprogramming.com/javascript/sort-json-key-value-javascript/
 */
function jsonSortByValue(jsonObject)
{
	var sortedArray = [];
	for(var i in jsonObject)
	{
		// Push each JSON Object entry in array by [value, key]
		sortedArray.push([jsonObject[i], i]);
	}

	return sortedArray.sort();
}

function number_format(number, decimals, dec_point, thousands_sep)
{
	number = (number + '').replace(/[^0-9+\-Ee.]/g, '');
	var n = !isFinite(+number) ? 0 : +number;
	var prec = !isFinite(+decimals) ? 0 : Math.abs(decimals);
	var sep = (typeof thousands_sep === 'undefined') ? '.' : thousands_sep;
	var dec = (typeof dec_point === 'undefined') ? ',' : dec_point;
	var s = '';

	toFixedFix = function (n, prec)
	{
		var k = Math.pow(10, prec)
		return '' + (Math.round(n * k) / k).toFixed(prec);
	}

	// Fix for IE parseFloat(0.55).toFixed(0) = 0;
	s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.')
	if (s[0].length > 3)
	{
		s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep)
  	}

	if ((s[1] || '').length < prec)
	{
		s[1] = s[1] || '';
		s[1] += new Array(prec - s[1].length + 1).join('0')
	}

	return s.join(dec)
}

function pad(num, size, place)
{
	var s = num+'';
	while (s.length < size)
	{
		if(place == 'right')
		{
			s = s + '0';
		}
		else
		{
			s = '0' + s;
		}
	}
	return s;
}

/**
 * { function_description }
 *
 * @param      {<type>}  object  The object
 * @param      {<type>}  keys    The keys
 * @return     {<type>}  { description_of_the_return_value }
 */
function extract(object, keys)
{
	if(!isObject(object))
	{
		return null;
	}

	var argumentLength = arguments.length;
	if(argumentLength > 2)
	{
		var _keys = [];
		for(var i in arguments)
		{
			if((i > 0) && (arguments.hasOwnProperty(i)))
			{
				_keys.push(arguments[i]);
			}
		}

		if(_keys.length > 1)
		{
			_keys = _keys;
		}
		else
		{
			_keys = _keys.shift();
		}
	}
	else
	{
		_keys = clone(keys);
	}

	if(isString(_keys))
	{
		if(typeof(object[_keys]) !== 'undefined')
		{
			return object[_keys];
		}
	}
	else if(isArray(_keys))
	{
		var key = _keys.shift();
		if(isString(key) || isNumeric(key))
		{
			if(typeof(object[key]) !== 'undefined')
			{
				if(_keys.length === 0)
				{
					return object[key];
				}
				else
				{
					return extract(object[key], _keys);
				}
			}
		}
	}

	return null;
}

function extractFromItem(response, field, itemNo)
{
	if(!isset(itemNo) || isNull(itemNo) || isEmpty(itemNo))
	{
		itemNo = 0;
	}

	return extract(response, 'data', itemNo, 'data', field);
}

/**
 * [getObjectValue description]
 * @return {[type]} [description]
 */
function getObjectValue()
{
	var argumentLength = arguments.length;
	if(argumentLength != 2)
	{
		return '';
	}
	else
	{
		return extract(arguments[0], arguments[1]);

		/**
		 * var object = null;
		 * var objectValue = '';
		 * 
		 * for(var i=0; i<argumentLength; i++)
		 * {
		 * 	if(isNull(object))
		 * 	{
		 * 		object = arguments[i];
		 * 	}
		 * 	else if(isset(object[arguments[i]]))
		 * 	{
		 * 		object = objectValue = object[arguments[i]];
		 * 	}
		 * }
		 * 
		 * return objectValue;
		 */
	}
}

/**
 * [stringShuffle description]
 * @method stringShuffle
 * @param  {[type]}      string [description]
 * @return {[type]}             [description]
 * discuss at: http://locutus.io/php/str_shuffle/
 * original by: Brett Zamir (http://brett-zamir.me)
 * example 1: var $shuffled = str_shuffle("abcdef")
 * example 1: var $result = $shuffled.length
 * returns 1: 6
 */
function stringShuffle(string)
{
	if (arguments.length === 0)
	{
		throw new Error('Wrong parameter count for str_shuffle()')
	}

	if (string === null)
	{
		return '';
	}

	string += '';

	var newString = '';
	var rand;
	var i = string.length;

	while (i)
	{
		rand = Math.floor(Math.random() * i);
		newString += string.charAt(rand);
		string = string.substring(0, rand) + string.substr(rand + 1);
		i--;
	}

	return newString
}

function stringReverse(string)
{
	if(isString(string))
	{
		return string.split('').reverse().join('');
	}
	return null;
}

function stringChunk(string, length)
{
	var regExp = new RegExp('.{1,'+length+'}', 'g');
	return string.match(regExp);
}

function convertNumeralSystem(value, from, to, format)
{
	convertedValue = parseInt(value, from).toString(to);
	if((typeof(format) == 'undefined') || !isFalse(format))
	{
		return formatNumber(convertedValue, to);
	}
	return convertedValue;
}

function formatNumber(value, numeralSystem)
{
	switch(numeralSystem)
	{
		case 2:
			return formatBinairyNumber(value);
			break;

		case 8:
			return formatOctalNumber(value);
			break;

		case 10:
			return formatDecimalNumber(value);
			break;

		case 16:
			return formatHexadecimalNumber(value);
			break;

		default:
			return formatDecimalNumber(value);
			break;

	}

	return value;
}

function formatBinairyNumber(value)
{
	// Go calculate the amount of missing zero's for a binary presentation. For example, when
	// the binary value is 100100, we'll add 2 zero's add the beginning, so the value will
	// become 00100100.
	//
	var missingZeros = (4-((value.length) % 4));
	var leadingZeros = '';
	if((missingZeros > 0) && (missingZeros < 4))
	{
		for(var i=0; i<missingZeros; i++)
		{
			leadingZeros += '0';
		}
	}

	// Revert string
	//
	value = stringReverse(value);

	// Split in chunks with length of 4
	//
	var chunks = stringChunk(value, 4);

	// Join with spaces
	//
	value = chunks.join(' ');

	// Reverse again and return, starting with the calculated leading zero's.
	//
	return leadingZeros + '' + stringReverse(value);
}

function formatOctalNumber(value)
{
	// Revert string
	//
	value = stringReverse(value);

	// Split in chunks with length of 3
	//
	var chunks = stringChunk(value, 3);

	// Join with spaces
	//
	value = chunks.join(' ');

	// Reverse again and return
	//
	return stringReverse(value);
}

function formatDecimalNumber(value)
{
	// Revert string
	//
	value = stringReverse(value);

	// Split in chunks with length of 3
	//
	var chunks = stringChunk(value, 3);

	// Join with spaces
	//
	value = chunks.join('.');

	// Reverse again and return
	//
	return stringReverse(value);

}

function formatHexadecimalNumber(value, formatAsHtml)
{
	// Uppercase
	//
	value = value.toUpperCase();

	// Revert string
	//
	value = stringReverse(value);

	// Split in chunks with length of 2
	//
	var chunks = stringChunk(value, 2);

	// Join with spaces
	//
	value = chunks.join(' ');

	// Reverse again and return
	//
	string = stringReverse(value);

	if(isTrue(formatAsHtml))
	{
		string = '<span class=\'fakeSpaceAfter\'>'+string.replace(/\s/g, "</span><span class=\'fakeSpaceAfter\'>")+'</span>';
	}

	return string;
}

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function binairyToOctal(value, format)
{
	return convertNumeralSystem(value, 2, 8, format);
}
function btoo(value, format){ return binairyToOctal(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function binairyToDecimal(value, format)
{
	return convertNumeralSystem(value, 2, 10, format);
}
function btod(value, format){ return binairyToDecimal(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function binairyToHexadecimal(value, format)
{
	return convertNumeralSystem(value, 2, 16, format);
}
function btoh(value, format){ return binairyToHexadecimal(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function octalToBinary(value, format)
{
	return convertNumeralSystem(value, 8, 2, format);
}
function otob(value, format){ return octalToBinary(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function octalToToDecimal(value, format)
{
	return convertNumeralSystem(value, 8, 10, format);
}
function otod(value, format){ return octalToToDecimal(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function octalToHexadecimal(value, format)
{
	return convertNumeralSystem(value, 8, 16, format);
}
function otoh(value, format){ return octalToHexadecimal(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function decimalToBinary(value, format)
{
	return convertNumeralSystem(value, 10, 2, format);
}
function dtob(value, format){ return decimalToBinary(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function decimalToOctal(value, format)
{
	return convertNumeralSystem(value, 10, 8, format);
}
function dtoo(value, format){ return decimalToOctal(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function decimalToHexadecimal(value, format)
{
	return convertNumeralSystem(value, 10, 16, format);
}
function dtoh(value, format){ return decimalToHexadecimal(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function hexadecimalToBinary(value, format)
{
	return convertNumeralSystem(value, 16, 2, format);
}
function htob(value, format){ return hexadecimalToBinary(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function hexadecimalToOctal(value, format)
{
	return convertNumeralSystem(value, 16, 8, format);
}
function htoo(value, format){ return hexadecimalToOctal(value, format); };

/**
 * { function_description }
 *
 * @param      {<type>}  value   The value
 * @param      {<type>}  format  The format
 * @return     {<type>}  { description_of_the_return_value }
 */
function hexadecimalToDecimal(value, format)
{
	return convertNumeralSystem(value, 16, 10, format);
}
function htod(value, format){ return hexadecimalToDecimal(value, format); };
	



function shortenText(value, maxLength)
{
	if(value.length > maxLength)
	{
		return value.substr(0, maxLength) + "..."
	}
	else
	{
		return value;
	}
}

 // eslint-disable-line camelcase
 // http://locutus.io/php/strings/strip_tags/
function strip_tags (input, allowed)
{
	if(typeof(input) != 'string') return '';

	//  discuss at: http://locutus.io/php/strip_tags/
	// original by: Kevin van Zonneveld (http://kvz.io)
	// improved by: Luke Godfrey
	// improved by: Kevin van Zonneveld (http://kvz.io)
	//    input by: Pul
	//    input by: Alex
	//    input by: Marc Palau
	//    input by: Brett Zamir (http://brett-zamir.me)
	//    input by: Bobby Drake
	//    input by: Evertjan Garretsen
	// bugfixed by: Kevin van Zonneveld (http://kvz.io)
	// bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)
	// bugfixed by: Kevin van Zonneveld (http://kvz.io)
	// bugfixed by: Kevin van Zonneveld (http://kvz.io)
	// bugfixed by: Eric Nagel
	// bugfixed by: Kevin van Zonneveld (http://kvz.io)
	// bugfixed by: Tomasz Wesolowski
	//  revised by: Rafał Kukawski (http://blog.kukawski.pl)
	//   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>')
	//   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'
	//   example 2: strip_tags('<p>Kevin <img src="someimage.png" onmouseover="someFunction()">van <i>Zonneveld</i></p>', '<p>')
	//   returns 2: '<p>Kevin van Zonneveld</p>'
	//   example 3: strip_tags("<a href='http://kvz.io'>Kevin van Zonneveld</a>", "<a>")
	//   returns 3: "<a href='http://kvz.io'>Kevin van Zonneveld</a>"
	//   example 4: strip_tags('1 < 5 5 > 1')
	//   returns 4: '1 < 5 5 > 1'
	//   example 5: strip_tags('1 <br/> 1')
	//   returns 5: '1  1'
	//   example 6: strip_tags('1 <br/> 1', '<br>')
	//   returns 6: '1 <br/> 1'
	//   example 7: strip_tags('1 <br/> 1', '<br><br/>')
	//   returns 7: '1 <br/> 1'
	// making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
	allowed = (((allowed || '') + '').toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join('');
	var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi
	var commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi
	return input.replace(commentsAndPhpTags, '').replace(
		tags,
		function ($0, $1)
		{
			return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : ''
		}
	);
}

/**
 * [trim description]
 * @method    trim
 * @date      2017-07-25
 * @author    S.vanBuren
 * @copyright (concera
 * @param     {[type]}   input    [description]
 * @param     {[type]}   charlist [description]
 * @return    {[type]}            [description]
 */
function trim(input, charlist)
{
	var whitespaces = [
		' ',
		"\n",
		"\r",
		"\t",
		"\f",
		"\x0b",
		"\xa0",
		"\u2000",
		"\u2001",
		"\u2002",
		"\u2003",
		"\u2004",
		"\u2005",
		"\u2006",
		"\u2007",
		"\u2008",
		"\u2009",
		"\u200a",
		"\u200b",
		"\u2028",
		"\u2029",
		"\u3000"
	];

	var whitespace = whitespaces.join('');
	var l = 0;
	var i = 0;
	input += '';
	
	if (charlist)
	{
		whitespace = (charlist + '').replace(/([[\]().?/*{}+$^:])/g, '$1');
	}
	
	l = input.length;
	for (i = 0; i < l; i++)
	{
		if (whitespace.indexOf(input.charAt(i)) === -1)
		{
			input = input.substring(i);
			break;
		}
	}
	
	l = input.length;
	for (i = l - 1; i >= 0; i--)
	{
		if (whitespace.indexOf(input.charAt(i)) === -1)
		{
			input = input.substring(0, i + 1);
			break;
		}
	}

	//
	return whitespace.indexOf(input.charAt(0)) === -1 ? input : '';
}

/**
 * [ltrim description]
 * @method    ltrim
 * @date      2017-07-25
 * @author    S.vanBuren
 * @copyright (concera
 * @param     {[type]}   input    [description]
 * @param     {[type]}   charlist [description]
 * @return    {[type]}            [description]
 */
function ltrim(input, charlist)
{
	charlist = !charlist ? ' \\s\u00A0' : (charlist + '').replace(/([[\]().?/*{}+$^:])/g, '$1')
	var re = new RegExp('^[' + charlist + ']+', 'g')
	return (input + '').replace(re, '');
}

/**
 * [rtrim description]
 * @method    rtrim
 * @date      2017-07-25
 * @author    S.vanBuren
 * @copyright (concera
 * @param     {[type]}   input    [description]
 * @param     {[type]}   charlist [description]
 * @return    {[type]}            [description]
 */
function rtrim(input, charlist)
{
	charlist = !charlist ? ' \\s\u00A0' : (charlist + '').replace(/([[\]().?/*{}+$^:])/g, '\\$1')
	var re = new RegExp('[' + charlist + ']+$', 'g')
	return (input + '').replace(re, '')
}

/**
 * [endEvent description]
 * @param  {[type]} e [description]
 * @return {[type]}   [description]
 * @source https://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag#5432363
 *
 */
function endEvent(e)
{
	if((typeof(e.stopPropagation) != 'undefined') && (typeof(e.stopPropagation) == 'function')) e.stopPropagation();
	if((typeof(e.preventDefault) != 'undefined') && (typeof(e.preventDefault) == 'function')) e.preventDefault();
	e.cancelBubble = true;
	e.returnValue = false;
	
	return false;
}

/**
 * This function can be used to append an paramater and its value to an
 * URL. Based on the URL, it will be added with a ? of &, followed by
 * the parameter and it's value.
 *
 * @example
 * _appendToUrl('index.php', 'param1', 'value1');
 * // returns index.php?param1=value1
 *
 * @example
 * _appendToUrl('index.php?param1=value1', 'param2', 'value2');
 * // returns index.php?param1=value1&param2=value2
 *
 * @method cocosAPI._appendToUrl
 * @access private
 * @param  {String}  url    The URL which need to be filled with an
 *                          extra parameter and value.
 * @param  {String}  param  The parameter to append to the URL.
 * @param  {String}  value  The value of the parameter.
 * @return {String}         The new URL, including the added parameter
 *                          and value.
 */
function appendToUrl(url, param, value)
{
	if(isObject(value))
	{
		var sendFullObject = false;

		$.each(value, function(k, subValue)
		{
			if(isObject(subValue))
			{
				// subValue = JSON.stringify(subValue);
				// url += ((url.indexOf('?') == -1)?'?':'&')+param+'[]='+encodeURIComponent(subValue);
				sendFullObject = true;
			}
			else
			{
				url += ((url.indexOf('?') == -1)?'?':'&')+param+'[]='+encodeURIComponent(subValue);
			}
		});

		if(isTrue(sendFullObject))
		{
			url += ((url.indexOf('?') == -1)?'?':'&')+param+'='+JSON.stringify(value);
		}
	}
	else
	{
		url += ((url.indexOf('?') == -1)?'?':'&')+param+'='+encodeURIComponent(value);
	}

	return url;
};

function ucFirst(string)
{
	return string.charAt(0).toUpperCase() + string.substr(1);
}

/**
 * [String.ucfirst description]
 * @source: https://www.geekality.net/2010/06/30/javascript-uppercase-first-letter-in-a-string/
 * @return {[type]} [description]
 */
if(typeof String.prototype.ucfirst !== 'function')
{
	String.prototype.ucfirst = function()
	{
		return this.charAt(0).toUpperCase() + this.substr(1);
	}
}

/**
 * { item_description }
 * @source: https://stackoverflow.com/questions/202605/repeat-string-javascript#202627
 */
if(typeof String.prototype.repeat !== 'function')
{
	String.prototype.repeat = function(count)
	{
		if (count < 1) return '';
		var result = '', pattern = this.valueOf();
		while (count > 1)
		{
			if (count & 1) result += pattern;
			count >>= 1, pattern += pattern;
		}
		return result + pattern;
	}
}

function escapeHtml(html)
{
	if(isString(html))
	{
		var escapeChars = {
			// '¢' : 'cent',
			// '£' : 'pound',
			// '¥' : 'yen',
			// '€' : 'euro',
			// '©' :'copy',
			// '®' : 'reg',
			'<' : 'lt',
			'>' : 'gt',
			//'"' : 'quot',
			// '&' : 'amp',
			//'\'' : '#39'
		};

		var regexString = '[';
		for(var key in escapeChars)
		{
	  		regexString += key;
		}
		regexString += ']';

		var regex = new RegExp( regexString, 'g');

		return html.replace(regex, function(m)
		{
	    		return '&' + escapeChars[m] + ';';
	  	});
	  }
}

/**
 * { function_description }
 *
 * @param      {string}  text    The text
 * @return     {string}  { description_of_the_return_value }
 */
function nl2br(text)
{
	if(isString(text))
	{
		return text.replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + '<br>' + '$2');
	}
}

/**
 * { function_description }
 *
 * @param      {string}  string  The string
 * @return     {<type>}  { description_of_the_return_value }
 */
function stringToCode(string)
{
	if(isString(string))
	{
		var tab = RegExp("\\t", 'g');
		string = string.replace(tab,'&nbsp;&nbsp;&nbsp;&nbsp;');
		return nl2br(string);
	}
}

/**
 * [getRequestParameter description]
 * @method    getRequestParameter
 * @date      2017-07-25
 * @author    S.vanBuren
 * @copyright (concera
 * @source    https://stackoverflow.com/questions/979975/how-to-get-the-value-from-the-get-parameters
 * @param     {[type]}            name [description]
 * @param     {[type]}            url  [description]
 * @return    {[type]}                 [description]
 */
function getRequestParameter(name, url)
{
	if (!url) url = location.href;
	name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
	var regexS = "[\\?&]"+name+"=([^&#]*)";
	var regex = new RegExp( regexS );
	var results = regex.exec( url );
	return results == null ? null : results[1];
}


/**
 * [restoreCoCoSApiID description]
 * @param  {[type]} encodedId [description]
 * @return {[type]}           [description]
 */
function restoreCoCoSApiID(encodedId)
{
	if(isCoCoSApiID(encodedId))
	{
		var encodedIdLength = encodedId.length;
		var restoredIdLength = parseInt(encodedId.substr(0, 2));

		if(isNumeric(restoredIdLength) && (parseInt(restoredIdLength) > 0))
		{
			restoredIdLength = parseInt(restoredIdLength);
			var restoredId = encodedId.substring((encodedIdLength-restoredIdLength), encodedIdLength);

			if(isNumeric(restoredId))
			{
				return parseInt(restoredId);
			}
		}
	}

	return encodedId;
}

/**
 * @brief      { function_description }
 * @param      encodedId  { parameter_description }
 * @return     { description_of_the_return_value }
 */
function isCoCoSApiID(encodedId)
{
	if(!isNull(encodedId) && !isEmpty(encodedId) && isString(encodedId))
	{
		if(encodedId.length > 3)
		{
			var encodedIdLength = encodedId.length;
			var restoredIdLength = encodedId.substr(0, 2);

			if(isNumeric(restoredIdLength))
			{
				var restoredId = encodedId.substring((encodedIdLength-restoredIdLength), encodedIdLength);
				return isNumeric(restoredId);
			}
		}
	}

	return false;
}

/**
 * [myClearTimeout description]
 * @param  {[type]} obj [description]
 * @return {[type]}     [description]
 */
function myClearTimeout(obj)
{
	// Native javascript-function
	//
	clearTimeout(obj);
	obj = null;
	return obj;
}

/**
 * [mySetTimeout description]
 * @param  {[type]} obj              [description]
 * @param  {[type]} callbackFunction [description]
 * @param  {[type]} timeout          [description]
 * @return {[type]}                  [description]
 */
function mySetTimeout(obj, callbackFunction, timeout)
{
	if(!isNull(obj))
	{
		obj = myClearTimeout(obj);
	}

	if(isset(callbackFunction) && isFunction(callbackFunction))
	{
		if(parseInt(timeout) > 0)
		{
			//
			obj = setTimeout
			(
				function()
				{
					callbackFunction();
				},
				timeout
			);

			return obj;
		}
		else
		{
			callbackFunction();
		}
	}

	return null;
}

/**
 * [myClearTimeout description]
 * @param  {[type]} obj [description]
 * @return {[type]}     [description]
 */
function myClearInterval(obj)
{
	// Native javascript-function
	//
	clearInterval(obj);
	obj = null;
	return obj;
}

function mySetInterval(obj, callbackFunction, timeout)
{
	if(!isNull(obj))
	{
		obj = myClearInterval(obj);
	}

	if(isset(callbackFunction) && isFunction(callbackFunction))
	{
		if(parseInt(timeout) > 0)
		{
			//
			obj = setInterval
			(
				function()
				{
					callbackFunction();
				},
				timeout
			);

			return obj;
		}
	}

	return null;
}


/**
 * [convertToLocalTime description]
 * @param  {[type]} value [description]
 * @return {[type]}       [description]
 */
function convertToLocalTime(value, dataOrFormat, metaOrformat, format)
{
	var data = {};
	var meta = {};

	if(isString(dataOrFormat))
	{
		format = dataOrFormat;
	}
	else
	{
		data = dataOrFormat;
		if(isString(metaOrformat))
		{
			format = metaOrformat;
		}
		else
		{
			meta = metaOrformat;
			if(isString(format))
			{
				format = format;
			}
		}
	}

	return utcToLocal(value, format);
}



/**
 * { utcToLocalDateTime }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function utcToLocalDateTime(value)
{
	return utcToLocal(value, 'Y-m-d H:i');
}

/**
 * { utcToLocalDateTimeSeconds }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function utcToLocalDateTimeSeconds(value)
{
	return utcToLocal(value, 'Y-m-d H:i:s');
}

/**
 * { utcToLocalDateTimeMilliseconds }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function utcToLocalDateTimeMilliseconds(value)
{
	return utcToLocal(value, 'Y-m-d H:i:s.u');
}

/**
 * { utcToLocalDateMicrotime }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function utcToLocalDateMicrotime(value)
{
	return utcToLocalDateTimeMilliseconds(value);
}

/**
 * { utcToLocalDate }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function utcToLocalDate(value)
{
	return utcToLocal(value, 'Y-m-d');
}

/**
 * { utcToLocalTime }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function utcToLocalTime(value, date)
{
	if(isString(value))
	{
		if(value.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2} .*$/g) === null)
		{
			if(isset(date) && !isEmpty(date))
			{
				value = date+' '+value;
			}
			else
			{
				value = '2000-01-01 '+value;
			}
		}
	}

	return utcToLocal(value, 'H:i');
}

/**
 * { utcToLocalTimeSeconds }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function utcToLocalTimeSeconds(value, date)
{
	if(isString(value))
	{
		if(value.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2} .*$/g) === null)
		{
			if(isset(date) && !isEmpty(date))
			{
				value = date+' '+value;
			}
			else
			{
				value = '2000-01-01 '+value;
			}
		}
	}

	return utcToLocal(value, 'H:i:s');
};

/**
 * { utcToLocalTimeSeconds }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function utcToLocalTimeMillliseconds(value, date)
{
	if(isString(value))
	{
		if(value.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2} .*$/g) === null)
		{
			if(isset(date) && !isEmpty(date))
			{
				value = date+' '+value;
			}
			else
			{
				value = '2000-01-01 '+value;
			}
		}
	}
	
	return utcToLocal(value, 'H:i:s.u');
};

/**
 * { utcToLocal }
 *
 * @param      {(number|string)}  value   The value
 * @param      {string}           format  The format
 * @return     {string}           { description_of_the_return_value }
 */
function utcToLocal(value, format)
{
	var date = null;
	var milliseconds = null;

	if(isString(value) && ((value.indexOf('-') > -1) || (value.indexOf(':') > -1)))
	{
		if(value.indexOf(':') == -1)
		{
			value += 'T00:00:00';
		}
		else if(value.split(':').length == 2)
		{
			value += ':00';
		}

		if(value.indexOf('-') == -1)
		{
			value = getLocalDate()+' '+value;
		}

		// Create local time from GMT/UTC time, input value should be the format
		// YYYY-MM-DD HH:ii:ss, for example 2016-01-02 03:34:45 which will be
		// converted into 2016-01-02T03:34:45.000Z
		//
		date = new Date(value.replace(/ /g,'T') + '.000Z');
	}
	else
	{
		var stringedValue = String(value);
		if(stringedValue.indexOf('.') > -1)
		{
			stringedValue = stringedValue.split('.');
			if(stringedValue.length == 2)
			{
				value = parseInt(stringedValue[0]);
				milliseconds = stringedValue[1];
			}
		}

		date = new Date(value*1000);
	}
	
	return formatDate(date, format, milliseconds);
};


/**
 * { getLocalDateTime }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function getLocalDateTime()
{
	return getLocal('Y-m-d H:i');
};

/**
 * { getLocalDateTimeSeconds }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function getLocalDateTimeSeconds()
{
	return getLocal('Y-m-d H:i:s');
};

/**
 * { getLocalDateTimeMilliseconds }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function getLocalDateTimeMilliseconds()
{
	return getLocal('Y-m-d H:i:s.u');
};

/**
 * { getLocalDateMicrotime }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function getLocalDateMicrotime()
{
	return getLocalDateTimeMilliseconds();
};

/**
 * { getLocalDate }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function getLocalDate()
{
	return getLocal('Y-m-d');
};

/**
 * { getLocalTime }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function getLocalTime()
{
	return getLocal('H:i');
};

/**
 * { getLocalTimeSeconds }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function getLocalTimeSeconds()
{
	return getLocal('H:i:s');
};

/**
 * { getLocalTimeSeconds }
 *
 * @param      {<type>}  value   The value
 * @return     {<type>}  { description_of_the_return_value }
 */
function getLocalTimeMilliseconds()
{
	return getLocal('H:i:s.u');
};


/**
 * { getLocal }
 *
 * @param      {(number|string)}  value   The value
 * @param      {string}           format  The format
 * @return     {string}           { description_of_the_return_value }
 */
function getLocal(format)
{
	var date = new Date();
	return formatDate(date, format);
};

/**
 * { formatDate }
 *
 * @param      {<type>}  date    The date
 * @param      {string}  format  The format
 * @return     {string}  { description_of_the_return_value }
 * 
 * Supporting formats:
 * 
 * 	Y	A full numeric representation of a year, 4 digits (Example 1999 or 2003)
 * 	y	A two digit representation of a year (Example 99 or 03)
 * 	
 * 	m	Numeric representation of a month, with leading zeros (01 to 12)
 * 	n	Numeric representation of a month, without leading zeros (1 to 12)
 * 	
 * 	d	Day of the month, 2 digits with leading zeros (01 to 31)
 * 	j	Day of the month without leading zeros (1 to 31)
 *
 *	H	24-hour format of an hour with leading zeros (00 to 23)
 * 	i	Minutes with leading zeros (00 to 59)
 *  	s	Seconds with leading zeros (00 to 59)
 *  	
 *  	u	Microseconds in 4 decimals precise.
 *  	v	Microseconds in 4 decimals precise.
 *  	
 *  	l	A full textual representation of the day of the week (Sunday to Saturday)
 *   	D	A textual representation of a day, three letters (Sun to Sat)
 *   	 
 *  	F	A full textual representation of a month (January to December)
 *  	M	A short textual representation of a month, three letters (Jan to Dec)
 * 
 */
function formatDate(date, format, milliseconds, language)
{	
	var placeholderCharacterRepeat	= 10

	// Some characters/formats will be converted into texts. To prevent these new texts from
	// getting parsed again, we'll replace them by a placeholder, which will be a string with
	// the character repeated for a few times, in this case 10.
	// 
	// For example, when using the format n F y, this will be converted (in case of the date
	// 2019-04-21) into '4 april 2019'. We don't want that the 'l' in 'april' to be used for the
	// textual representation of the day again. Because then, the date 2019-04-21 will be
	// formatted to '4 aprisunday 19'.
	// 
	// To prevent this, we will change the format from 'n F y' to 'n FFFFFFFFF y' and use the
	// placeholder 'FFFFFFFFFF' to be replaced by the full textual representation of the month.
	// The placeholder 'llllllllll' will be used for for the textual representation of the day,
	// but this won't exist in 'april', so the full textual representation of the month will be
	// 'april' and won't be modified.
	// 
	var characterDayText		= 'l';
	var placeholderDayText		= characterDayText.repeat(placeholderCharacterRepeat);

	var characterDayTextShort	= 'D';
	var placeholderDayTextShort	= characterDayTextShort.repeat(placeholderCharacterRepeat);

	var characterMonthText		= 'F';
	var placeholderMonthText	= characterMonthText.repeat(placeholderCharacterRepeat);

	var characterMonthTextShort	= 'M';
	var placeholderMonthTextShort	= characterMonthTextShort.repeat(placeholderCharacterRepeat);

	var weekdayText = null;
	var monthText = null;

	// Check if a valid date is given
	//
	if(!isNaN(date.valueOf()) && (date.valueOf() > 0))
	{
		if(!isset(format) || isEmpty(format) || !isString(format))
		{
			format = 'Y-m-d H:i:s';
		}

		format = format.replace(/Y/g, date.getFullYear());
		format = format.replace(/y/g, date.getFullYear().toString().substr(2, 2));
		
		format = format.replace(/m/g, pad((date.getMonth()+1), 2));
		format = format.replace(/n/g, (date.getMonth()+1));

		format = format.replace(/d/g, pad(date.getDate(), 2));
		format = format.replace(/j/g, date.getDate());

		format = format.replace(/H/g, pad(date.getHours(), 2));
		format = format.replace(/i/g, pad(date.getMinutes(), 2));
		format = format.replace(/s/g, pad(date.getSeconds(), 2));

		format = format.replace(/U/g, Math.round(date.getTime()/1000));

		if(!isNull(milliseconds))
		{
			format = format.replace(/u|v/g, pad(milliseconds, 4, 'right'));
		}
		else
		{
			format = format.replace(/u|v/g, pad(date.getMilliseconds(), 4, 'right'));
		}

		// Check if the character for the full or short textual representation for the day
		// exists in the format, if so, go replace it with it's placeholder. Also, when
		// one of these is used, go get the weekdayText, based on the weekday for the date.
		// 
		if((format.indexOf(characterDayText) > -1) || (format.indexOf(characterDayTextShort) > -1))
		{
			var regExp = new RegExp(characterDayText, 'g');
			format = format.replace(regExp, placeholderDayText);

			var regExp = new RegExp(characterDayTextShort, 'g');
			format = format.replace(regExp, placeholderDayTextShort);

			var weekday = date.getDay();
			weekdayText = getWeekdayText(weekday, language);
			if(isNull(weekdayText))
			{
				 weekdayText = '';
			}
		}

		// Check if the character for the full or short textual representation for the month
		// exists in the format, if so, go replace it with it's placeholder. Also, when
		// one of these is used, go get the monthText, based on the month for the date.
		// 
		if((format.indexOf(characterMonthText) > -1) || (format.indexOf(characterMonthTextShort) > -1))
		{
			var regExp = new RegExp(characterMonthText, 'g');
			format = format.replace(regExp, placeholderMonthText);

			var regExp = new RegExp(characterMonthTextShort, 'g');
			format = format.replace(regExp, placeholderMonthTextShort);

			var month = date.getMonth();
			monthText = getMonthText(month, language);
			if(isNull(monthText))
			{
				 monthText = '';
			}
		}

		// Go check the format for any placeholders. When found, go replace them
		//
		if(format.indexOf(placeholderDayText) > -1)
		{
			var regExp = new RegExp('('+escapeRegExp(placeholderDayText)+')', 'g');
			format = format.replace(regExp, weekdayText);
		}

		if(format.indexOf(placeholderDayTextShort) > -1)
		{
			var regExp = new RegExp('('+escapeRegExp(placeholderDayTextShort)+')', 'g');
			format = format.replace(regExp, weekdayText.substr(0, 3));
		}

		if(format.indexOf(placeholderMonthText) > -1)
		{
			var regExp = new RegExp('('+escapeRegExp(placeholderMonthText)+')', 'g');
			format = format.replace(regExp, monthText);
		}

		if(format.indexOf(placeholderMonthTextShort) > -1)
		{
			var regExp = new RegExp('('+escapeRegExp(placeholderMonthTextShort)+')', 'g');
			format = format.replace(regExp, monthText.substr(0, 3));
		}

		// After creating a date-time object using javascript default functions,
		// return the new date in local time using the same format as requested,
		// so YY-MM-DD HH:ii:ss. When the local time is in a +02:00 timezone,
		// this function will return 2016-01-02 05:34:45 (2 hours later compared
		// to the original value)
		//
		/* return pad(date.getFullYear(), 4) + "-" +
			pad((date.getMonth()+1), 2) + "-" +
			pad(date.getDate(), 2) + " " +
			pad(date.getHours(), 2) + ":" +
			pad(date.getMinutes(), 2) + ":" +
			pad(date.getSeconds(), 2);
		*/
	
		return format;
	}

	return '';
};

/**
 * Gets the month text.
 *
 * @param      {<type>}  monthno  The monthno
 * @return     {Array}   The month text.
 */
function getMonthText(monthno, language)
{
	if(!isset(language) || isEmpty(language))
	{
		language = getBrowserLanguage();
	}
	
	var monthTexts = [
		'January',	// 0
		'February',	// 1
		'March',	// 2
		'April',	// 3
		'May',		// 4
		'June',		// 5
		'July',		// 6
		'August',	// 7
		'September',	// 8
		'October',	// 9
		'November',	// 10
		'December'	// 11
	];

	switch(language)
	{
		case 'nl':
			monthTexts = [
				'januari',	// 0
				'februari',	// 1
				'maart',	// 2
				'april',	// 3
				'mei',		// 4
				'juni',		// 5
				'juli',		// 6
				'augustus',	// 7
				'september',	// 8
				'oktober',	// 9
				'november',	// 10
				'december'	// 11
			];
			break;
	}

	return monthTexts[monthno];
};

/**
 * Gets the weekday text.
 *
 * @param      {<type>}  weekday  The weekday
 * @return     {Array}   The weekday text.
 */
function getWeekdayText(weekday, language)
{
	if(!isset(language) || isEmpty(language))
	{
		language = getBrowserLanguage();
	}

	var dayTexts = [
		'sunday',	// 0
		'monday',	// 1
		'tuesday',	// 2
		'wednesday',	// 3
		'thursday',	// 4
		'friday',	// 5
		'saturday'	// 6
	];

	switch(language)
	{
		case 'nl':
			dayTexts = [
			'zondag',	// 0
			'maandag',	// 1
			'dinsdag',	// 2
			'woensdag',	// 3
			'donderdag',	// 4
			'vrijdag',	// 5
			'zaterdag'	// 6
		];
	}

	return dayTexts[weekday];
};

/**
 * { function_description }
 *
 * @param      {string}  string  The string
 * @return     {string}  { description_of_the_return_value }
 * @source     https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
 */
function escapeRegExp(string) {
	return string.replace(/[.*+?^!@#$%{}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
};

/**
 * { function_description }
 *
 * @param      {string}  text    The text
 */
function executeStringConversions(text)
{
	var regExpConversions = /(\{.*?\-\>.*?\})/gm;
	var textConversions = text.match(regExpConversions);
	if(!isNull(textConversions) && isArray(textConversions) && (textConversions.length > 0))
	{
		for(k in textConversions)
		{
			var textConversion = textConversions[k];

			var textAndFunction = textConversion.substring(1, textConversion.length-1).split(/->/);
			var convertText = textAndFunction[0].toString();
			var convertFunction = textAndFunction[1].toString();

			if(!isEmpty(convertFunction))
			{
				switch(convertFunction.toLowerCase())
				{
					case 'ucfirst':
						convertText = convertText.ucfirst();
						break;

					case 'tolower':
					case 'tolowercase':
						convertText = convertText.toLowerCase();
						break;

					case 'toupper':
					case 'touppercase':
						convertText = convertText.toUpperCase();
						break;
				}
				text = text.replace(textConversion, convertText);
			}
		}
	}

	return text;
};

/**
 * { function_description }
 *
 * @param      {<type>}  text    The text to copy
 */
function copyToClipboard(valueToCopy)
{
	/* Get unique ID for field */
	var fieldId = 'cpfld_'+getUniqueId();

	/* Create fieldElement */
	var fieldElement = document.createElement('input');
	fieldElement.setAttribute('id', fieldId);

	/* Append field to DOM-Document */
	document.body.appendChild(fieldElement);

	/*  Get field from DOM-Document */
	var fieldInDom = document.getElementById(fieldId);

	if(fieldInDom != null)
	{
		/* Set the URL as value for the field */
		fieldInDom.value = valueToCopy;

		/* Select the text in the field */
		fieldInDom.select();

		/* Copy the text from inside the field */
		document.execCommand('copy');

		/* Remove the field from the DOM-Document */
		fieldInDom.remove();

		return true;
	}

	return false;
};

/**
 * { item_description }
 */
function copyWindowLocationToClipboard()
{
	/* Get URL to copy */
	var urlToCopy = window.location.href;

	copyToClipboard(urlToCopy);

	/* Return the copied URL */
	return urlToCopy;
};

/**
 * { function_description }
 *
 * @param      {number}           duration  The duration
 * @return     {(number|string)}  { description_of_the_return_value }
 */
function convertDuration(duration, showMilliseconds)
{
	if(!isEmpty(duration))
	{
		durationFloat = parseFloat(duration);
		durationInt = parseInt(duration);

		if(durationFloat < 1)
		{
			return (durationFloat*1000) + 'ms';
		}
		else
		{
			var days = Math.floor((durationInt % 31536000) / 86400); 
			var hours = Math.floor(((durationInt % 31536000) % 86400) / 3600);
			var minutes = Math.floor((((durationInt % 31536000) % 86400) % 3600) / 60);
			var seconds = (((durationInt % 31536000) % 86400) % 3600) % 60;
			var milliseconds = Math.round((durationFloat - durationInt)*1000);

			if((minutes < 1) && ((hours == 0) && (days == 0)))
			{
				if(!isFalse(showMilliseconds))
				{
					return seconds+'.'+milliseconds + 's'
				}
				else
				{
					return seconds+'s';
				}
			}
			else if((hours < 1) && (days == 0))
			{
				return minutes + 'm ' + seconds+'s';
			}
			else if(days < 1)
			{
				return hours + 'h ' + minutes + 'm ' + seconds + 's';
			}
			else
			{
				return days + 'd ' + hours + 'h ' + minutes + 'm';
			}
		}
	}

	return;
};

/**
 * Gets the daylight saving time offset for the current date.
 *
 * @return     {<type>}  The daylight saving time offset.
 */
function getDaylightSavingTimeOffset()
{
	// Get current time
	//
	var now = new Date();

	// Use the getTimezoneOffset()-function to get the time difference between UTC time and
	// local time, in minutes. For example, If your time zone is GMT+2, -120 will be returned.
	// 
	var timezoneOffsetNow = now.getTimezoneOffset();

	// Convert the timezoneOffset. Based on the example above, when the timezoneOffset is -2 for
	// GMT+2, we'll make it positive (* -1) and add seconds (*60). After this, the GMT+2 will
	// have an timezone offset of 7200. In case of daylight saving time, the timezoneOffset for
	// GMT+2 will be -3, which will result into 10800.
	//
	timezoneOffsetNow = ((timezoneOffsetNow*-1)*60);
	
	// Now, we'll use a date where no daylight saving time (zomertijd) is active. We'll use new
	// year's day for this, because we're sure we're having 'wintertijd' then.
	//
	var newYearsDay = new Date('2000-01-01');

	// Convert the timezoneOffset. Based on the example above, when the timezoneOffset is -2 for
	// GMT+2, we'll make it positive (* -1) and add seconds (*60). After this, the GMT+2 will
	// have an timezone offset of 7200. Because no daylight saving time is active on the 1st of
	// January, this will always be 7200 for GMT+2.
	//
	var timezoneOffsetNewYearsDay = newYearsDay.getTimezoneOffset();
	timezoneOffsetNewYearsDay = ((timezoneOffsetNewYearsDay*-1)*60);

	// Now, go calculate the difference between the timezone offset, based on the current time
	// and the timezone offset from new year's day. During daylight saving time, this will
	// probably 3600. Otherwise, when daylight saving time isn't active, both offsets will be
	// the same, so the result will be 0.
	// 
	// Based on the above example, using GMT+2, the timezoneOffsetNow will be 7200 (no daylight
	// saving time) or 10800 (daylight saving time) and the timezoneOffsetNewYearsDay will
	// always be 7200. So the offset will be 0 (7200-7200) or 3600 (10800-7200).
	//
	var daylightSavingTimeOffset = (timezoneOffsetNow-timezoneOffsetNewYearsDay);

	// Return the daylightSavingTimeOffset (in seconds). When the offset is 3600, this means we
	// need to increase a timestamp with it, before converting it to a local time. So in
	// daylight saving time, GMT+2 will actually be/act like GMT+3.
	//
	return daylightSavingTimeOffset;
};

/**
 * Creates a new instance of the object with same properties than original.
 *
 * @param      {<type>}        obj     The object
 * @return     {(Array|Date)}  Copy of this object.
 */
function clone(obj)
{
	var copy;

	// Handle the 3 simple types, and null or undefined
	if (null == obj || "object" != typeof obj) return obj;

	// Handle Date
	if (obj instanceof Date)
	{
		copy = new Date();
		copy.setTime(obj.getTime());
		return copy;
	}

	// Handle Array
	if (obj instanceof Array)
	{
		copy = [];
		for (var i = 0, len = obj.length; i < len; i++)
		{
    			copy[i] = clone(obj[i]);
		}
		return copy;
	}

	// Handle Object
	if (obj instanceof Object)
	{
		copy = {};
		for (var attr in obj)
		{
    			if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
		}
		return copy;
	}
}

/**
 * Splits a name.
 *
 * @param      {(Function|string|string[])}  name    The name
 * @return     {Array}                       { description_of_the_return_value }
 */
function splitName(name)
{
	var initials = '', firstName = '', insertion = [], lastName = '';

	var nameArr = name.split(/\s+/);
	if(nameArr.length == 1)
	{
		firstName = name;
		insertion = "";
		lastName = "";
	}
	else if(nameArr.length == 2)
	{
		lastName = nameArr.pop();
		insertion = "";
		firstName = nameArr.join(' ');
	}
	else
	{
		var detect = null;

		for (var i = 0; i < nameArr.length; i++)
		{
			if(detect !== false)
			{
				if(["van", "von", "der", "de", "den", "in", "t", "'t", "la", "le", "ten", "ter"].indexOf(nameArr[i]) > -1)
				{
					insertion.push(nameArr[i]);
					detect = true;
				}
				else if(detect === true)
				{
					detect = false;
				}
			}
		}

		if(insertion.length > 0)
		{
			insertion = insertion.join(' ');
			var nameArr = name.split(' '+insertion+' ');
			firstName = nameArr.shift();
			lastName = name.replace(firstName + ' ' + insertion, '');
		}
		else
		{
			var lastnameArr = name.split(/-/);
			if(lastnameArr.length > 1)
			{
				var newName = splitName(lastnameArr.shift());
				firstName = newName[1];
				lastName = newName[3]+"-"+lastnameArr.join('-');
			}	
			else
			{				
				lastName = nameArr.pop();
				insertion = "";
				firstName = nameArr.join(' ');	
			}
		}
	}

	return [
		firstNameToInitials(firstName),
		firstName,
		insertion,
		lastName
	];
}

/**
 * { function_description }
 *
 * @param      {<type>}    firstName  The first name
 * @return     {string[]}  { description_of_the_return_value }
 */
function firstNameToInitials(firstName)
{
	initials = [];
	firstNames = firstName.split(/\s+/);
		
	for(var i=0; i<firstNames.length; i++)
	{
		initials.push(firstNames[i].substr(0, 1).toUpperCase())
	}

	return initials.join('.') + '.';
}

/**
 * @brief      { function_description }
 * @param      b       { parameter_description }
 * @return     { description_of_the_return_value } */
function filesize(b)
{
    var u = 0, s=1024;
    while (b >= s || -b >= s) {
        b /= s;
        u++;
    }
    return (u ? b.toFixed(1) + ' ' : b) + ' KMGTPEZY'[u] + 'B';
}

/**
 * { function_description }
 *
 * @param      {number}  num     The number
 * @return     {<type>}  { description_of_the_return_value }
 * @see        https://stackoverflow.com/questions/6137986/javascript-roundoff-number-to-nearest-0-5
 */
function roundHalf(num)
{
    return Math.round(num*2)/2;
}

/**
 * @brief      { function_description }
 * @param      accessCode  { parameter_description }
 * @return     { description_of_the_return_value }
 */
function isValidStringWithChecksum(string)
{
	//
	if(string.length > 4)
	{	
		//
		var stringChecksum = string.substr(-4);
		var originalString = string.substr(0, (string.length-4));		
		var stringMd5 = md5(originalString);

		//
		if(stringMd5.substr(0, 4).toUpperCase() == stringChecksum)
		{
			return true;
		}
	}

	//
	return false;
}

/**
 * { function_description }
 *
 * @return     {string}  { description_of_the_return_value }
 */
function _regExpRgbColor()
{
	return '^rgb\\((\\d{1,3}%?),\\s*(\\d{1,3}%?),\\s*(\\d{1,3}%?)\\)$';
}

/**
 * { function_description }
 *
 * @return     {string}  { description_of_the_return_value }
 */
function _regExpRgbaColor()
{
	return '^rgba\\((\\d{1,3}%?),\\s*(\\d{1,3}%?),\\s*(\\d{1,3}%?),\\s*(\\d*(?:\\.\\d+)?)\\)$';
}

/**
 * { function_description }
 *
 * @return     {string}  { description_of_the_return_value }
 */
function _regExpHexColor()
{
	return '^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$';
}

/**
 * Determines whether the specified input is rgb color.
 *
 * @param      {string}            input   The input
 * @return     {(boolean|string)}  True if the specified input is rgb color, False otherwise.
 */
function isRGBColor(input)
{
	if(!isString(input)) return false;
	return (input.match(new RegExp(_regExpRgbColor(),'i')) !== null);
}	

/**
 * Determines whether the specified input is rgba color.
 *
 * @param      {string}            input   The input
 * @return     {(boolean|string)}  True if the specified input is rgba color, False otherwise.
 */
function isRGBAColor(input)
{
	if(!isString(input)) return false;
	return (input.match(new RegExp(_regExpRgbaColor(),'i')) !== null);
}

/**
 * Determines whether the specified input is hexadecimal color.
 *
 * @param      {string}            input   The input
 * @return     {(boolean|string)}  True if the specified input is hexadecimal color, False otherwise.
 */
function isHexColor(input)
{
	if(!isString(input)) return false;
	return (input.match(new RegExp(_regExpHexColor(),'i')) !== null);
}

/**
 * { function_description }
 *
 * @param      {string}  rgbString  The rgb string
 * @return     {Object}  { description_of_the_return_value }
 */
function rgbStringToRgbObject(rgbString)
{
	var rgb = rgbString.match(new RegExp(_regExpRgbColor(),'i'));
	if(!isNull(rgb))
	{
		return {r: parseInt(rgb[1]), g: parseInt(rgb[2]), b: parseInt(rgb[3])};
	}

	return null;
}

/**
 * { function_description }
 *
 * @param      {string}  rgbaString  The rgba string
 * @return     {Object}  { description_of_the_return_value }
 */
function rgbaStringToRgbaObject(rgbaString)
{
	var rgba = rgbaString.match(new RegExp(_regExpRgbaColor(),'i'));
	if(!isNull(rgba))
	{
		return {r: parseInt(rgba[1]), g: parseInt(rgba[2]), b: parseInt(rgba[3]), a: parseFloat(rgba[4])};
	}

	return null;
}

/**
 * { function_description }
 *
 * @param      {<type>}  rgbString  The rgb string
 * @return     {<type>}  { description_of_the_return_value }
 */
function rgbStringToHexString(rgbString)
{
	var rgb = rgbStringToRgbObject(rgbString);
	if(!isNull(rgb))
	{
		return rgbObjectToHexString(rgb);
	}

	return '';
}

/**
 * { function_description }
 *
 * @param      {<type>}  rgbaString  The rgba string
 * @return     {<type>}  { description_of_the_return_value }
 */
function rgbaStringToHexString(rgbaString)
{
	var rgba = rgbaStringToRgbaObject(rgbaString);
	if(!isNull(rgb))
	{
		return rgbaObjectToHexString(rgb);
	}

	return '';
}

/**
 * { function_description }
 *
 * @param      {number}  r       { parameter_description }
 * @param      {number}  g       { parameter_description }
 * @param      {<type>}  b       { parameter_description }
 * @return     {string}  { description_of_the_return_value }
 */
function rgbToHexString(r,g,b)
{
	return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

/**
 * { function_description }
 *
 * @param      {<type>}  rgbObject  The rgb object
 * @return     {<type>}  { description_of_the_return_value }
 */
function rgbObjectToHexString(rgbObject)
{
	return rgbToHexString(rgbObject.r,rgbObject.g,rgbObject.b);
}

/**
 * { function_description }
 *
 * @param      {number}  r       { parameter_description }
 * @param      {number}  g       { parameter_description }
 * @param      {<type>}  b       { parameter_description }
 * @param      {<type>}  a       { parameter_description }
 * @return     {string}  { description_of_the_return_value }
 */
function rgbaToHexString(r,g,b,a)
{
	// Can't handle alpha in hex-color, so just use rgbToHexString, without parameter a.
	//
	return rgbToHexString(r,g,b);
}

/**
 * { function_description }
 *
 * @param      {<type>}  rgbaObject  The rgba object
 * @return     {<type>}  { description_of_the_return_value }
 */
function rgbaObjectToHexString(rgbaObject)
{
	return rgbaToHexString(rgbaObject.r,rgbaObject.g,rgbaObject.b,rgbaObject.a);
}

/**
 * { function_description }
 *
 * @param      {string}  hex     The hexadecimal
 * @return     {Object}  { description_of_the_return_value }
 */
function hexStringToRgbObject(hex)
{
	hex = hex.match(new RegExp(_regExpHexColor(),'i'));
	return {r: parseInt(hex[1], 16),g: parseInt(hex[2], 16),b: parseInt(hex[3], 16)};
}

/**
 * { function_description }
 *
 * @param      {<type>}  hex     The hexadecimal
 * @return     {<type>}  { description_of_the_return_value }
 */
function hexStringToRgbString(hex)
{
	var reg = hexStringToRgbObject(hex);
	if(!isNull(rgb))
	{
		return rgbObjectToRgbString(rgb);
	}

	return '';
}

/**
 * { function_description }
 *
 * @param      {<type>}  hex     The hexadecimal
 * @param      {number}  alpha   The alpha
 * @return     {<type>}  { description_of_the_return_value }
 */
function hexStringToRgbaString(hex, alpha)
{
	if(typeof(alpha) == 'undefined') alpha = 1;

	//
	var rgb = hexStringToRgbObject(hex);
	if(!isNull(rgb))
	{
		return rgbToRgbaString(rgb.r, rgb.g, rgb.b, alpha);
	}

	return '';
}

/**
 * { function_description }
 *
 * @param      {string}  r       { parameter_description }
 * @param      {string}  g       { parameter_description }
 * @param      {string}  b       { parameter_description }
 * @return     {string}  { description_of_the_return_value }
 */
function rgbToRgbString(r,g,b)
{
	return 'rgb('+r+','+g+','+b+')';
}	

/**
 * { function_description }
 *
 * @param      {<type>}  rgbObject  The rgb object
 * @return     {<type>}  { description_of_the_return_value }
 */
function rgbObjectToRgbString(rgbObject)
{
	return rgbToRgbString(rgbObject.r,rgbObject.g,rgbObject.b);
}

/**
 * { function_description }
 *
 * @param      {string}  r       { parameter_description }
 * @param      {string}  g       { parameter_description }
 * @param      {string}  b       { parameter_description }
 * @param      {string}  a       { parameter_description }
 * @return     {string}  { description_of_the_return_value }
 */
function rgbaToRgbaString(r,g,b,a)
{	
	if(typeof(alpha) == 'undefined') alpha = 1;

	//
	return 'rgba('+r+','+g+','+b+','+a+')';
}

/**
 * { function_description }
 *
 * @param      {<type>}  rgbaObject  The rgba object
 * @return     {<type>}  { description_of_the_return_value }
 */
function rgbaObjectToRgbaString(rgbaObject)
{	
	return rgbaToRgbaString(rgbaObject.r,rgbaObject.g,rgbaObject.b,rgbaObject.a);
}

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHslObject(r, g, b)
{
	r /= 255, g /= 255, b /= 255;
	var max = Math.max(r, g, b), min = Math.min(r, g, b);
	var h, s, l = (max + min) / 2;

	if(max == min)
	{
		h = s = 0; // achromatic
	}
	else
	{
		var d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch(max)
		{
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}

	return {h: h, s:s, l:l};
}

/**
 * { function_description }
 *
 * @param      {<type>}  rgbObject  The rgb object
 * @return     {<type>}  { description_of_the_return_value }
 */
function rgbObjectToHslObject(rgbObject)
{
	return rgbToHslObject(rgbObject.r,rgbObject.g,rgbObject.b);
}

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   {number}  h       The hue
 * @param   {number}  s       The saturation
 * @param   {number}  l       The lightness
 * @return  {Array}           The RGB representation
 */
function hslToRgb(h, s, l)
{
	var r, g, b;

	if(s == 0)
	{
		r = g = b = l; // achromatic
	}
	else
	{
		var hue2rgb = function hue2rgb(p, q, t)
		{
			if(t < 0) t += 1;
			if(t > 1) t -= 1;
			if(t < 1/6) return p + (q - p) * 6 * t;
			if(t < 1/2) return q;
			if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
			return p;
		}

		var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		var p = 2 * l - q;
		r = hue2rgb(p, q, h + 1/3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1/3);
	}

	return {r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255)};
}

/**
 * { function_description }
 *
 * @param      {<type>}  hslObject  The hsl object
 * @return     {<type>}  { description_of_the_return_value }
 */
function hslObjectToRgbObject(hslObject)
{
	return hslToRgb(hslObject.h,hslObject.s,hslObject.l);
}

/**
 * { function_description }
 *
 * @param      {<type>}  color       The color
 * @param      {number}  lightness   The lightness
 * @return     {<type>}  { description_of_the_return_value }
 */
function changeColorLightness(color, lightness)
{
	var rgbColor = false;
	var rgbaColor = false;
	var hexColor = false;

	var rgb = null;
	var alpha = 1;

	if(isRGBColor(color))
	{
		rgbColor = true;
		rgb = rgbStringToRgbObject(color);
	}
	else if(isRGBAColor(color))
	{
		rgbaColor = true;
		rgb = rgbaStringToRgbaObject(color);
		alpha = rgb.a;
	}
	else if(isHexColor(color))
	{
		hexColor = true;
		rgb = hexStringToRgbObject(color);
	}

	if(rgb !== null)
	{
		//
		var hsl = rgbObjectToHslObject(rgb);

		if(lightness > 100) lightness = 100;
		if(lightness < -100) lightness = -100;

		if((lightness > 1) || (lightness < -1)) lightness = (lightness/100);

		if(lightness > 0) hsl.l = hsl.l + ((1-hsl.l) * lightness);
		else if(lightness < 0) hsl.l = hsl.l - hsl.l * Math.abs(lightness);

		if(hsl.l <= 0) hsl.l = 0;
		if(hsl.l >= 1) hsl.l = 1;

		//
		rgb = hslObjectToRgbObject(hsl);

		if(rgbColor)
		{
			return rgbObjectToRgbString(rgb);
		}
		else if(rgbaColor)
		{
			var rgba = rgb
			rgba['a'] = alpha;
			return rgbaObjectToRgbaString(rgba);
		}
		else if(hexColor)
		{
			return rgbObjectToHexString(rgb);
		}
	}

	return null;
}

/**
 * { function_description }
 *
 * @param      {<type>}  colorSting  The color sting
 * @return     {<type>}  { description_of_the_return_value }
 */
function colorStringToRgbObject(colorSting)
{
	var rgb = null;

	if(isRGBColor(colorSting))
	{
		rgb = rgbStringToRgbObject(colorSting);
	}
	else if(isRGBAColor(colorSting))
	{
		rgb = rgbaStringToRgbaObject(colorSting);
	}
	else if(isHexColor(colorSting))
	{
		rgb = hexStringToRgbObject(colorSting);
	}
	
	if(rgb !== null)
	{
		return rgb;
	}

	return null;
}

/**
 * { function_description }
 *
 * @param      {<type>}  colorString  The color string
 * @return     {<type>}  { description_of_the_return_value }
 */
function colorStringToHslObject(colorString)
{
	rgb = colorStringToRgbObject(colorString)
	if(!isNull(rgb))
	{
		var hsl = rgbObjectToHslObject(rgb);
		if(!isNull(hsl))
		{
			return hsl;
		}
	}

	return null;
}

/**
 * Gets the contrast color for rgb.
 *
 * @param      {number}  r           { parameter_description }
 * @param      {number}  g           { parameter_description }
 * @param      {number}  b           { parameter_description }
 * @param      {number}  a           { parameter_description }
 * @param      {string}  colorDark   The color dark
 * @param      {string}  colorLight  The color light
 * @return     {string}  The contrast color for rgb.
 */
function getContrastColorForRgb(r,g,b,a,colorDark,colorLight)
{
	if(!isset(colorDark)) colorDark = '#000000';
	if(!isset(colorLight)) colorLight = '#FFFFFF';

	var brightness = r * 0.299 + g * 0.587 + b * 0.114 + (1 - a) * 255;
	return brightness > 180 ? "#000000" : "#FFFFFF";
}

/**
 * Gets the contrast color for rgb object.
 *
 * @param      {<type>}  rgbObject   The rgb object
 * @param      {<type>}  darkColor   The dark color
 * @param      {<type>}  lightColor  The light color
 * @return     {string}  The contrast color for rgb object.
 */
function getContrastColorForRgbObject(rgbObject,darkColor,lightColor)
{
	if(rgbObject !== null)
	{
		return getContrastColorForRgb(rgbObject.r,rgbObject.g,rgbObject.b,1,darkColor,lightColor);
	}

	return '';
}

/**
 * Determines whether the specified color string is a light color.
 *
 * @param      {<type>}   colorString  The color string
 * @return     {boolean}  True if the specified color string is a light color, False otherwise.
 */
function isLightColor(colorString)
{
	var rgb = colorStringToRgbObject(colorString);
	var contrastColor = getContrastColorForRgbObject(rgb);
	return (contrastColor == '#000000');
}

/**
 * Determines whether the specified color string is a dark color.
 *
 * @param      {<type>}   colorString  The color string
 * @return     {boolean}  True if the specified color string is a dark color, False otherwise.
 */
function isDarkColor(colorString)
{
	return isFalse(isLightColor(colorString));
}